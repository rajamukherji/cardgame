def (Stdin, Stdout) in import("io/terminal")
def (
	DrawPile, Hand, DiscardPile, Modifiers, Counters, Goals, 
	playable, draw, discard, choose, display, log, start
) in import("game")
import: cards("cards")

random::seed(time():nsec)

Counters["influence"] := 0
Counters["value"] := 0
Counters["daily_energy"] := 3
Counters["draw_count"] := 4

DrawPile:put(
	cards::project({"Size" is 3, "Cost" is 1}),
	cards::developer({"Skill" is 1}),
	cards::training({"Cost" is 1}),
	cards::bigshot({"Cost" is 1}),
	cards::customer({"Cost" is 2, "Value" is 3}),
	cards::plan({
		"Cost" is 1,
		"Size" is 4,
		"Task" is {"Cost" is 3, "Skill" is 3},
		"Goal" is cards::workshop,
		"Details" is {
			"Cost" is 4,
			"Value" is 5
		}
	}),
	cards::plan({
		"Cost" is 1,
		"Size" is 2,
		"Task" is {"Cost" is 2, "Skill" is 2},
		"Goal" is cards::presentation,
		"Details" is {"Cost" is 1, "Value" is 1}
	}),
	cards::order({
		"Cost" is 1,
		"Size" is 3,
		"Order" is cards::coffee
	}),
	cards::retrospective({}),
	cards::practioner({"Influence" is 10}),
	cards::recruiter({"Cost" is 2}),
	cards::event({"Events" is [
		(0.1, cards::training, {"Cost" is 2}),
		(0.05, cards::practioner, {"Influence" is 10})
	]})
)
DrawPile:shuffle

choose := fun(Seq, CostFn := 0) do
	let Cards := list(Seq)
	Cards:length > 0 or ret nil
	Stdout:write(' Choose a card (\e[32m0\e[0m: Cancel or Skip):\n')
	for I, Card in Cards do
		if I = 1 then
			Stdout:write(' ╔', 39 * '═', '╗\n')
		else
			Stdout:write(' ╠', 39 * '═', '╣\n')
		end
		let Cost := CostFn(Card) or ""
		let Number := '{I}:'
		let Name := Card:name
		let LeftPadding := 39 - Name:length div 2
		let RightPadding := 39 - Name:length - LeftPadding
		Stdout:write(' ║\e[32m{Number}\e[39m{LeftPadding - Number:length * " "}\e[4m{Name}\e[24m{RightPadding - Cost:length * " "}\e[31m{Cost}\e[39m║\n')
		var Description := Card:description
		loop
			while Description:length > 36
			for I in 37 .. 1 by -1 do
				if Description[I] = " " then
					Stdout:write(' ║  {Description[1, I]}{37 - I * " "} ║\n')
					Description := old[I + 1, 0]
					exit
				end
			else
				Stdout:write(' ║  {Description[1, 37]} ║\n')
				Description := old[37, 0]
			end
		end
		Stdout:write(' ║  {Description}{36 - Description:length * " "} ║\n')
	end
	Stdout:write(' ╚', 39 * '═', '╝\n')
	Stdout:write("\n")
	loop
		Stdout:write(" Choice: ")
		let Index := integer(Stdin:read:trim)
		if Index = 0 then
			ret nil
		elseif let Card := Cards[Index] then
			:>Stdout:write('Choosing {Index} -> {Card}\n')
			ret Card
		end
	on Error do
		Stdout:write('Error: {Error}\n')
	end
end

display := Stdout:write(_)

let Events := []
log := Events:put(_)

start(
	fun(Day) do	
		Counters["energy"] := Counters["draw_count"]
	end,
	fun(Day) do
		let Title := 'Day {Day}'
		let LeftPadding := 42 - Title:length div 2
		let RightPadding := 42 - Title:length - LeftPadding
		Stdout:write('\e[2J\e[H\e[44m{LeftPadding * " "}Day {Day}{RightPadding * " "}\e[0m\n')
		Stdout:write(' Value: \e[32m{Counters["value"]}\e[0m, Influence: \e[32m{Counters["influence"]}\e[0m\n')
		Stdout:write(' Cards: [\e[33m{DrawPile:length}] / [{DiscardPile:length}\e[0m], Energy: \e[31m{reduce("", @" ●" limit Counters["energy"], +)}\e[0m \n\n')
		if Events:length > 0 then
			each Events -> Stdout:write(" • ", _, "\n")
			Stdout:write("\n")
			Events:empty
		end
	end
)
